### http 缓存
通常用户缓存页面中不太变动的静态资源，如：css、图片

- 强制缓存
> 判断是否过期，未过期，则直接使用；已过期，重新请求服务器
- 协商缓存
> 每次都先询问一下服务器来验证有效性。如果有效，返回304状态码，告诉客户端当前使用的是本地缓存；如果无效，则返回新的内容给客户端

### 强制缓存
1. 响应头，设置expires
     - http1.0 中使用
     - 缺点：
        - 对本地时间强依赖。如，本地时间修改了 或 本地时间和服务器时间不同步，都将导致缓存可能不生效，不符合预期。
2. 响应头，cache-control: no-cache | no-store
    - 也可应用在协商缓存中
    - no-cache 强制进行协商缓存
    - no-store 禁止任何的缓存策略
    - max-age 单位：秒，设置的是滑动时间，即 依据当前的时间+滑动时间判断缓存是否失效

### 协商缓存
1. last-modify
    - 记录文件上一次修改的时间戳。如果文件的时间戳和上一次的不同，则返回新内容，否则使用缓存内容
    - 缺点：
        - 如果文件修改的间隔是在1s内，那么会无法识别到资源的更新
        - 如果只变动了文件名，但最后又设置回原先的文件名，实际内容无变化 => 重新请求，但是即这个请求是不必要的，这回导致带宽资源的浪费，延长用户获取到资源的时间

2. 基于ETag的协商机制
    - 实体标签 Entity Tag
    - 服务器为不同资源进行哈希运算生成一个字符串，这个字符串相当于文件的指纹，用于感知文件是否更新了。如果更新了，服务器重新返回内容，如果未更新，则客户端使用缓存内容

### Q&A
- 为什么我设置了强制缓存却不生效？
    - 看一下控制台是否开启了"停用缓存"，如果是，关闭"停用缓存"即可
- request.headers 是一个对象
- 为什么没看到请求头中的If-Modified-Since？
    - https://segmentfault.com/q/1010000007008829/